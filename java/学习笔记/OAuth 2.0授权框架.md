# OAuth 2.0授权框架

[rfc6749](https://tools.ietf.org/html/rfc6749)

文档中有两个词要注意区分：

* Authentication: 身份认证
* Authorization: 授权

## 摘要

OAuth 2.0授权框架是关于如何让第三方应用能够有限制地访问HTTP服务。第三方应用可以通过发起资源所有者和HTTP服务之间的授权交互过程来代表资源所有者，或者代表第三方应用自身。OAuth 2.0规范取代并淘汰RFC 5849中定义的OAuth 1.0协议。

## 该备忘录的状态

这是一份用来记录互联网标准的文档。  
这份文档由互联网工程任务组（Internet Engineering Task Force, IETF）发布。它代表了IETF社区的共同意见。它经过了公共检视，并经过了互联网工程指导组（Internet Engineering Steering Group, IESG）的准许而公布。更多关于互联网标准的信息，请参考[RFC 5741 段落2](https://tools.ietf.org/html/rfc5741#section-2)

## 1.介绍

传统的Client-Server授权模式中，客户端请求服务器上的访问受限资源，要用资源所有者的凭证来做身份认证。为了让第三方应用访问资源，资源所有者把自己的凭证交给第三方。这导致以下问题：

* 第三方应用需要把资源所有者的凭证保存起来以供将来使用，通常是明文密码
* 服务器需要支持密码身份认证，尽管密码在安全性方面较弱
* 第三方应用能够获取的资源范围过大，而资源所有者无法限制期限或者仅允许获取一小部分资源
* 资源所有者无法对特定的第三方收回授权而不会把所有的第三方的权限都收回，并且必须通过修改密码才能收回权限
* 任何第三方应用被攻破，都会导致用户密码泄露，进而危害到该密码保护的所有数据

OAuth通过引入授权层，把“客户端”和“资源所有者”作为两个角色区分开，来解决这些问题。在OAuth框架下，资源由所有者控制，托管在资源服务器，客户端请求资源时，不再采用资源所有者的凭证，而是另外一组不同的凭证。  

客户端通过获取一个access token来访问受保护的资源。access token是一个字符串，包含了授权范围，授权期限，以及其他关于资源使用权的属性信息。access token是由授权服务器经过资源所有者同意后提供给客户端的。客户端使用access token来获取托管在资源服务器上的受保护资源。  

例如，一个终端用户（资源所有者）可以给打印服务（客户端）授权，允许获取她存放在照片共享服务（资源服务器）上的照片。她不需要把账号密码告诉打印服务，而是直接和一个被照片共享服务信任的服务器（授权服务器）进行授权，由这个服务器给打印服务提供一个委托凭证（access token）。  

本规范的设计只考虑使用HTTP。使用其他协议来实现开放授权不在本规范的范围内。  

OAuth 1.0协议（RFC5849)，作为一个信息文档发布，是一个小社区的努力成果。本篇标准记录规范是基于OAuth 1.0的经验，同时考虑了从更广泛的IETF社区收集到的更多的使用场景和扩展性需求。OAuth 2.0协议不向后兼容OAuth 1.0。（向后兼容：“后”是“落后”的意思，不兼容旧版本）。两个版本可以在网络中同时存在，实现者也许会同时支持两者。但是，本规范的意图是：新的实现要支持OAuth 2.0，而OAuth 1.0只用来兼容已有的程序。OAuth 2.0协议只有一小部分实现细节能够和OAuth 1.0共用。熟悉OAuth 1.0的实现者使用本文档时不要对其结构和细节有任何假设。

### 1.1 四个角色

* 资源所有者：可以对受保护资源的获取进行授权的主体。如果资源所有者是一个人，指的就是终端用户。
* 资源服务器：托管了受保护资源的服务器，能够接收使用access token来获取资源的请求并作出响应。
* 客户端：代表资源所有者，并携带着自身凭证，对受保护资源发出请求的应用。“客户端”这个词并不暗示任何的实现特征（比如，应用是运行在服务端，还是桌面，或者其他设备）。
* 授权服务器：在于成功地与资源所有者完成授权过程并拿到授权后，给客户端颁发access token的服务器。

授权服务器和资源所有者的交互不在本规范的范围内。授权服务器可以和资源服务器是同一个，也可以是分开的。一台授权服务器可以颁发多台资源服务器识别的access token。

### 1.2 协议流程

```txt
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

               Figure 1: Abstract Protocol Flow
```

图1展示了抽象的OAuth 2.0流程图，描述了四个角色之间的交互流程，包含以下几步：

* (A)客户端请求资源所有者的授权。这个授权请求可以直接发给资源所有者（如图），或者更好的是采用非直接的方式，由授权服务器做为中间人。
* (B)客户端收到了授权许可，一份代表资源所有者授权的凭证，用本规范中定义的四种授权类型之一，或者是用扩展的授权类型来表达。
* (C)客户端向授权服务器请求access token，通过和授权服务器做身份验证，并出示授权许可。
* (D)授权服务器验证客户端身份，并鉴定授权许可，如果是合法的，则颁发access token。
* (E)客户端向资源服务器请求受保护的资源，并通过出示access token来进行权限认证。
* (F)资源服务器鉴定access token的合法性，如果合法，则为客户端的请求提供服务。

### 1.3 授权许可

授权许可是代表资源所有者的授权（获取其受保护的资源）的凭证，客户端用它来获取access token。本规范定义了四种授权模式——授权码，隐式，资源所有者密码凭证，客户端凭证；同时给出了定义其他授权类型的扩展机制。

#### 1.3.1 授权码

授权码是通过让授权服务器作为客户端和资源所有者的中介而生成的。客户端不直接向资源你所有者请求授权，而是把资源所有者引导到授权服务器（通过在RFC2616中定义的用户代理）；授权服务器之后再把用户重定向到客户端，重定向时还带着授权码。  

在携带者授权码把资源所有者引导回客户端之前，授权服务器验证资源所有者的身份并获取授权。因为资源所有者只和资源服务器进行身份认证，所以资源所有者不需要把身份凭证和客户端共享。  

授权码提供了一些重要的安全方面的好处，比如，客户端自己的身份认证以及获取access token的过程，可以直接让客户端和授权服务器交互，而不需要通过资源所有者的用户代理，这样就不会把客户端自身凭证和access token暴露给其他人，包括资源所有者。

#### 1.3.2 隐式授权

隐式授权是简化的授权码流程，针对使用如JavaScript的脚本语言实现于浏览器内的客户端而做的优化。在隐式授权流程中，不生成授权码，而是直接生成access token（作为资源所有者授权的结果）。这个授权类型是隐式的，因为没有中间凭证（比如授权码）产生（之后用来获取access token）。  

在隐式授权流程中生成access token时，授权服务器不认证客户端的身份。在某些场景下，客户端的身份可以通过传递access token给客户端用的redirect URI来识别。access token会被暴露给资源所有者，或者其他可以访问资源所有者的用户代理的程序。  

隐式授权提高了一些客户端（比如浏览器应用程序）的响应能力和性能，因为它减少了获取access token的交互次数。然而，这种便利与安全是对立的，使用隐式授权会带来一些问题，比如在10.3和10.16章节描述的问题。尤其在能够使用授权码模式的场景下，应该慎重考虑使用隐式授权。

#### 1.3.3 资源所有者密码凭证

资源所有者密码凭证（比如，用户名和密码）可以被直接当做授权许可来获取access token。这种凭证只应该用于资源所有者和客户端之间高度信任（比如，客户端是设备操作系统的一部分或者是特权应用），并且其他无法采用其他授权模式的场景。  

尽管这种授权模式下客户端直接获取了资源所有者的凭证，但资源所有者的凭证仅被用一次，用于交换access token。这种模式避免了客户端保存资源所有者的凭证以供将来使用，而是用凭证换取了一个可长期使用的access token或者refresh token。

#### 1.3.4 客户端凭证

客户端凭证（获取其他形式的客户端身份认证）可以被用来作为授权凭证，当授权范围限制在客户端控制下的受保护资源，或者授权服务器事先安排好的受保护资源。客户端凭证用来作为授权凭证，一般是在客户端代表其自己进行活动，或者请求访问的是授权服务器事先安排好的资源。

### 1.4 Access Token

access token是用来获取受保护资源的凭证。access token是一个字符串，代表给客户端的授权。这个字符串通常是对客户端透明的。token代表了资源访问的特定范围和期限，由资源所有者授权，由资源服务器和授权服务器实施。  

token可以包含一个检索授权信息的id，也可以用可验证的方式（比如，token字符串包含数据和签名）自包含授权信息。也可以要求客户端提供额外的授权凭证来使用token，但这不在本规范的范围内。  

access token提供了一个抽象层，用单一的token取代了不同授权结构（比如，用户名和密码）。这层抽象使生成access token可以在授权许可上加上更严格的限制，也使资源服务器不用去理解那些范围很广的授权方法。  

access token可以有不同的格式，结构，和使用方法（比如，加密属性），这些可以基于资源服务器的安全需求来决定。access token的属性和用它来获取受保护资源的方法，不在本规范的范围内，这些由配套的规范来定义，比如[RFC6750](https://tools.ietf.org/html/rfc6750)。  

### 1.5 Refresh Token

refresh token是用来获取access token的凭证。refresh token由授权服务器颁发给客户端，当当前的access token失效或者过期时，用refresh token来获取一个新的access token；或者用来获取额外的拥有相同或者更窄的权限范围的access token（access token也许会比资源所有者的授权有更短的有效期或者更少的权限）。是否生成refresh token是基于授权服务器自己的考量。如果生成refresh token的话，则是在生成access token的时候一起生成。  

refresh token是一个字符串，代表了资源所有者对客户端的授权。这个字符串通常是对客户端透明的。refresh token表示一个检索授权信息的id。不同于access token，refresh token仅用于和授权服务器的交互，而不会发送给资源服务器。

```txt
  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               Figure 2: Refreshing an Expired Access Token
```

### 1.6 TLS版本

在TLS应用于本协议的任何时候，基于开发普及程度和已知的安全漏洞，合适的TLS版本会随着时间变化。在本文档编写的时刻，TLS 1.2是最新的版本，但是只有很少的开发基础，也许还没有为实现做好准备。TLS 1.0是被最开发最广的版本，可以提供最大的可交互性。  

实现者可以支持其他满足他们安全需求的传输层安全机制。

### 1.7 HTTP重定向

本规范大量地使用了HTTP重定向，客户端或者授权服务器把资源所有者的用户代理导向到另一个目的地。在本规范的例子中使用了HTTP 302状态码，但是任何其他可以使用户代理完成重定向的方式都是可以用的，这被视为实现细节。

### 1.8 交互性

OAuth 2.0提供了一个具有良好安全属性的，内容丰富的授权框架。但是，作为一个内容丰富、高度可扩展、有许多可选组件的框架，于其自身，本规范给出的可能是大量的的无交互的实现方案。  

另外，本规范对一些必须的组件，只做了部分定义，甚至完全没有定义（比如，客户端注册，授权服务器的能力，端侧发现）。没有这些组件，客户端必须人工去配置授权服务器和资源服务器，才能进行交互。

这个框架设计出来是明确期望将来可以定义更多规范或者扩展，以实现全网络内的可交互性。

## 2.客户端注册

### 2.1 客户端类型

* confidential 可以保护好自己的凭证
* public 不能保护好自己的凭证

客户端类型的指定是基于授权服务器对安全认证的定义和它可接受的客户端凭证的暴露级别。  

本规范主要针对以下几种客户端场景

* web应用
* 基于用户代理的应用（内嵌在浏览器中的应用）**TODO 不知道这样的例子**
* 原生应用（手机APP或者桌面应用）

### 2.2 客户端id

一个唯一代表客户端的字符串

### 2.3 客户端身份认证

#### 2.3.1 客户端密码

授权服务器必须支持HTTP Basic认证

```txt
  Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
```

作为可选方案，也可以支持把客户端凭证放到请求体中，参数名称为client_id和client_secret。使用这两个参数把客户端凭证放到请求体中是不建议的，而且应该被限制用在客户端无法直接使用HTTP Basic认证（或其他基于密码的HTTP身份认证框架）。这些参数只能被放在请求体中，而一定不能放在请求URI中。  

比如，刷新access token的请求如下

```txt
     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
     &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

#### 2.3.2 其他身份认证方法

授权服务器可以支持任何合适的满足其安全要求的HTTP身份认证框架。当使用其他身份认证方法时，授权服务器必须定义客户端id和身份认证框架的映射关系。

### 2.4 注销客户端

略。

## 3.协议端点

授权过程利用了两个授权服务器端点（HTTP资源）：

* 授权端点 - 客户端用来通过用户代理重定向来获取资源所有者的授权。
* token端点 - 客户端用来用授权凭证换取access token，通常会带着客户端的身份认证。

同样还有一个客户端端点

* 重定向端点 - 授权服务器用来返回包含授权许可的响应给客户端，通过资源所有者的用户代理。

并不是每种授权模式都使用了两种端点。扩展的授权模式也可以根据需要定义其他的端点。

### 3.1 授权端点

授权端点用来与资源所有者交互，并获取授权许可。授权服务器必须先验证资源所有者的身份。授权服务器验证资源所有者身份的方法（比如，用户名和密码登录，会话cookies），不在本协议的范围内。

客户端获取授权服务器端点的地址的方法，不在本协议的范围内，但是这个地址通常在服务文档中提供。

端点URI可以包含"application/x-www-form-urlencoded"格式的查询部分，它们在增加其他查询参数的时候必须被保留。端点URI必须不包含fragment部分。

由于给授权端点的请求会触发用户身份认证并且在HTTP响应中传输明文的凭证，授权服务器必须要求**发送给授权端点的请求使用TLS**。

授权服务器必须支持对授权端点的HTTP的GET方法，也可以同时支持POST方法。

没有值的参数必须当做没有传递。授权服务器必须忽略不识别的参数。请求和响应参数必须不能出现多次。

#### 3.1.1 响应类型

授权端点被用在授权码模式和隐式授权模式流程中。客户端通过如下参数告诉授权服务器期望的授权类型

* response_type 必填参数。值必须是"code"或者"token"，或者注册过的扩展值。

如果授权请求中缺少"reponse_type"参数，或者其值无法理解，授权服务器必须返回一个错误响应，定义在4.1.2.1。

#### 3.1.2 重定向端点

在完成与资源所有者的交互之后，授权服务器把资源所有者的用户代理重定向回客户端。授权服务器重定向用户代理到客户端的重定向端点，这个端点是客户端注册过程中给授权服务器的，或者是在发送授权请求的过程中给授权服务器的。

重定向端点URI必须是一个绝对路径URI。这个端点URI可以包含"aplication/x-www-form-unlencoded"格式的查询部分，他们在增加其他查询的时候必须被保留。端点URI必须不包含fragment部分。

##### 3.1.2.1 端点请求的保密性

当请求的response type为"code"或者"token"时，或者当重定向请求会导致敏感凭证通过公网传输时，重定向端点最好使用TLS。本规范没有强制要求使用TLS，是因为在写作本文档时，要求客户端部署TLS对许多客户端开发者来说还有很大的障碍。如果不是使用TLS，授权服务器应该在重定向之前提醒资源所有者端点的不安全性（比如，在授权过程中显示一条信息）。

缺少TLS会对客户端和其授权访问的受保护资源的安全性产生严重的影响。当授权过程是通过由客户端代理终端用户进行身份认证的形式进行（比如，第三方登录服务），TLS显得更为必要。

##### 3.1.2.2 注册要求

授权服务器必须要求以下客户端注册他们的重定向端点

* 公共客户端
* 使用隐式授权的私密客户端

授权服务器应该要求所有的客户端在使用使用授权端点之前注册他们的重定向端点。

授权服务器应该要求**客户端提供完整的重定向URI**（客户端可以使用"state"请求参数来做到每个请求都定制）。如果无法要求注册完整重定向URI，授权服务器应该要求注册URI scheme、授权、路径（允许客户端在请求授权的时候动态修改重定向URI，但仅允许修改查询参数）。

授权服务器可以允许客户端注册多个重定向端点。

缺少对重定向URI的注册要求，会导致攻击者把授权端点作为一个"开放重定向"，在段落10.15中详细描述。

##### 3.1.2.3 动态配置

如果注册了多个重定向URI，或者只注册了重定向URI的一部分，或者没有注册重定向URI，客户端必须在授权请求中携带"redirect_uri"参数。

当在授权请求中携带了重定向URI，如果有注册过URI，则授权服务器必须将其和已注册的URI进行比较和匹配，至少要匹配已注册URI中的一个。如果客户端注册信息中包含了完整的重定向URI，则授权服务器必须用[RFC3986]中定义的简单字符串比较来比较请求中的URI和注册URI。

##### 3.1.2.4 非法端点

如果授权请求因为重定向URI的缺失、非法、不匹配而失败，则授权服务器应该通知资源所有者这个错误，并且必须不要自动把用户代理重定向到非法的URI。

##### 3.1.2.5 端点内容

重定向请求到客户端端点，通常会是HTML文档响应，由用户代理来处理。如果HTML响应是直接由重定向请求导致的，任何包含在html中的脚本都可以获取到重定向URI以及其中包含的凭证。

**客户端不应该在重定向端点的响应中包含任何第三方脚本**。客户端可以从URI中提取凭证，然后把用户代理再次重定向到另一个端点，而不暴露凭证。如果包含第三方脚本，则客户端必须保证它自己的脚本（用来提取并移除URI中的凭证）会先执行。

### 3.2 token端点

token端点是客户端用来获取access token的，获取的方式是提供授权凭证或者refresh token。除了隐式授权模式，其他授权模式都会使用到token端点。

客户端如何获取token端点地址，不在本规范的范围。

端点URI可以包含查询参数。

授权服务器必须使用TLS。

客户端必须使用POST请求来获取access token。

无值的参数当做没有。忽略不识别的参数。请求和响应中的参数都只能出现一次。

#### 3.2.1 客户端身份认证

私密客户端或者其他分配了客户端身份凭证的客户端，在发请求给token端点时，必须进行身份认证。客户端身份认证用于：

* 把refresh token和授权码和它们被授予的客户端绑定。在授权码通过非安全通道传递给重定向端点或者重定向URI没有被完整注册的场景，客户端身份认证显得尤为重要。
* 通过修改客户端凭证来挽救脆弱的客户端，阻止攻击者滥用偷到的refresh token。修改客户端的单个凭证比收回一组refresh token要快得多了。
* 遵从身份认证管理的最佳实践，要求定期更新身份凭证。更新一组refresh token是很有挑战的，而更新客户端的单个身份凭证就要简单得多了。

当发送请求给token端点时，客户端可以使用"client_id"请求参数来标识自己。在授权码模式中，一个未经过身份验证的客户端必须发送"client_id"，来防止自己非有意地拿到了一个给其他client_id的授权码。这可以保护客户端应对授权码被替换的风险。（并没有给受保护资源提供额外的安全）。

### 3.3 access token范围

授权端点和token端点允许客户端指定访问请求的范围，通过"scope"请求参数。同样，授权服务器用"scope"响应参数来通知客户端生成的access token的范围。

## 4.获取授权

### 4.1 授权码模式

```txt
     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- & Redirection URI ---->|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates --->|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---<|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |>---(D)-- Authorization Code ---------'      |
     |  Client |          & Redirection URI                  |
     |         |                                             |
     |         |<---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)

   Note: The lines illustrating steps (A), (B), and (C) are broken into
   two parts as they pass through the user-agent.

                     Figure 3: Authorization Code Flow
```

#### 4.1.1 授权请求

#### 4.1.2 授权响应

##### 4.1.2.1 错误响应

如果因为重定向URI缺失、非法、不匹配而导致请求失败，授权服务器应该通知资源所有者，并且必须不能自动把用户代理重定向到非法的URI。

如果资源所有者拒绝访问请求或者其他不是由重定向URI缺失或非法导致的请求失败，授权服务器通过在重定向URI中添加请求参数通知客户端失败的原因，使用"applicaiton/x-www-form-urlencoded"格式。

error 必填。值是以下一种：

* invalid_request
* unauthorized_client
* access_denied
* unsupported_response_type
* invalid_scope
* server_error
* temporarily_unavailable

error参数的值必须不超出以下范围： %x20-21 / %x23-5B / %x5D-7E（也就是除了x23:# 和 x5C:\）

error_descprition 可选。

error_uri 可选。关于错误的更详细信息，给客户端开发者阅读。

state 如果请求中有这个参数，则返回值中必须也带有参数，值和请求中的值一致。

### 4.2 隐式授权模式

```txt
     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier     +---------------+
     |         -+----(A)-- & Redirection URI --->|               |
     |  User-   |                                | Authorization |
     |  Agent  -|----(B)-- User authenticates -->|     Server    |
     |          |                                |               |
     |          |<---(C)--- Redirection URI ----<|               |
     |          |          with Access Token     +---------------+
     |          |            in Fragment
     |          |                                +---------------+
     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |
     |          |          without Fragment      |     Client    |
     |          |                                |    Resource   |
     |     (F)  |<---(E)------- Script ---------<|               |
     |          |                                +---------------+
     +-|--------+
       |    |
      (A)  (G) Access Token
       |    |
       ^    v
     +---------+
     |         |
     |  Client |
     |         |
     +---------+

   Note: The lines illustrating steps (A) and (B) are broken into two
   parts as they pass through the user-agent.

                       Figure 4: Implicit Grant Flow
```

### 4.3 资源所有者密码凭证模式

```txt
     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          v
          |    Resource Owner
         (A) Password Credentials
          |
          v
     +---------+                                  +---------------+
     |         |>--(B)---- Resource Owner ------->|               |
     |         |         Password Credentials     | Authorization |
     | Client  |                                  |     Server    |
     |         |<--(C)---- Access Token ---------<|               |
     |         |    (w/ Optional Refresh Token)   |               |
     +---------+                                  +---------------+

            Figure 5: Resource Owner Password Credentials Flow
```

### 4.4 客户端凭证模式

```txt
     +---------+                                  +---------------+
     |         |                                  |               |
     |         |>--(A)- Client Authentication --->| Authorization |
     | Client  |                                  |     Server    |
     |         |<--(B)---- Access Token ---------<|               |
     |         |                                  |               |
     +---------+                                  +---------------+

                     Figure 6: Client Credentials Flow
```

## 5.生成access token

### 5.1 成功的响应

授权服务器在响应信息中包含token，凭证，或者其他敏感信息时，必须在响应头中为"Cache-Control"字段设值为"no-store"，为"Pragma"设值为"no-cache"。

## 6.刷新access token

## 7.访问受保护的资源

### 7.1 acess token类型

acess token类型给客户端提供了使用access token（带着类型相关的属性）访问受保护资源的必要信息。客户端在不理解token类型时必须不能使用acess token。

比如，对于[RFC6750]中定义的"bearer"类型，使用token仅需在请求中包含acess token字符串。

```txt
     GET /resource/1 HTTP/1.1
     Host: example.com
     Authorization: Bearer mF_9.B5f-4.1JqM
```

而对于"mac"类型，使用token需要生成消息验证码。

```txt
     GET /resource/1 HTTP/1.1
     Host: example.com
     Authorization: MAC id="h480djs93hd8",
                        nonce="274312:dj83hs9s",
                        mac="kDZvddkndxvhGRXZhvuDjEWhGeE="
```

上述例子只是为了演示。建议开发者在使用之前先参考[RFC6750]和[OAuth-HTTP-MAC]规范。

每个acess token类型定义都可以定义额外的属性，和"access_token"一起发送给客户端。它同时也定义了请求受保护资源时携带acess token的HTTP身份认证方法。

### 7.2 错误响应

错误响应的规范不在本协议的范围内。

## 8.扩展

### 8.1 定义acess token类型

有两种方式定义acess token类型：在acess token类型注册中心（段落11.1描述了注册过程）注册，或者用一个具有唯一性的绝对路径URI来表示它的名字。

使用URI作为名字的类型，应该仅用于不具有通用性的厂商专用实现，并且是针对使用它们的资源服务器的实现细节做定制。

所有其他的类型必须被注册。类型名称需要符合对应ABNF规则。如果类型定义包含新的HTTP身份认证方案（scheme），则access token类型名字应该和HTTP身份认证方案的名字一样。token类型"example"是保留的，用于举例。

```txt
     type-name  = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA
注：
ABNF是一个语法规则。Augmented Backus-Naur Form，扩展的巴克斯-奈儿范式。
/是或的意思。DIGIT表示数字0-9。ALPHA表示字母A-Z,a-z。1*表示一个或者更多元素。
```

### 8.2 定义新的端点参数

### 8.3 定义新的授权许可类型

### 8.4 定义新的授权端点响应类型

### 8.5 定义新的错误码

## 9.原生APP

原生APP是在资源所有者的设备上安装和运行的客户端（比如，桌面应用，原生手机APP）。原生APP需要考虑安全，平台能力和终端用户的体验。

授权端点需要和客户端以及资源所有者的用户代理交互。原生APP可以调用外部的用户代理或者内嵌一个用户代理。

* 外部用户代理 - 原生APP可以捕获授权服务器的响应，通过使用重定向URI，在操作系统中注册了一个scheme，调用客户端作为处理者，手工拷贝凭证，运行一个本地web服务器，安装用户代理的扩展，或者提供一个重定向URI识别在客户端控制下的托管于服务器的资源，反过来让原生APP获取到响应。
* 内嵌用户代理 - 原生APP通过直接与内嵌的用户代理交互获取响应，通过监视资源加载时发生的状态改变，或者获取用户代理的cookie。

当选择使用外部还是内嵌用户代理时，开发者需要考虑：

* 外部用户代理可以提高完成率，因为资源所有者可能已经有一个和授权服务器之间的活动的会话，避免了重新进行身份认证。它为终端用户提供了熟悉的体验和功能。资源所有者可以依赖用户代理的特性或者扩展来帮助做身份认证（比如，密码管理器，双因子设备读取器）。
* 内嵌的用户代理可以提供更高的可用性，因为它避免了上下文切换和打开新窗口。
* 内嵌用户代理带来安全方面的挑战，因为资源所有者进行身份认证是在一个未识别的窗口中，没有在大多数外部用户代理中可以看到的保护。内嵌的用户代理让终端用户信任未识别的身份认证请求（钓鱼攻击更容易）。

当使用隐式授权模式和授权码模式，以下需要被考虑：

* 原生APP使用授权码模式，应该不使用客户端凭证，因为原生APP没有能力保证客户端凭证的私密性。
* 当使用隐式授权模式，不返回refresh token，当access token过期时需要重复一次授权过程。

## 10.安全方面的考虑

作为一个灵活可扩展的框架，OAuth的安全方面的考虑基于很多因素。以下段落为实现者提供安全引导，主要集中在三种客户端类型：web应用，基于用户代理的应用，原生APP。

### 10.1 客户端身份认证

授权服务器必须不要给原生APP或基于用户代理的应用赋予客户端密码或者其他客户端身份凭证。授权服务器可以给在特定设备上特定安装的原生APP授予客户端密码或其他客户端凭证。

当客户端身份认证不可实施时，授权服务器应该使用其他手段来验证客户端的id，比如，要求注册重定向URI，或者让资源所有者来确认客户端的身份。仅凭一个重定向URI还不足以验证客户端的身份，当要求资源所有者授权时，但是可以用来在获取资源所有者同意之后，阻止把凭证发放给伪造的客户端。

授权服务器必须考虑隐藏的安全问题，与未经认证的客户端交互，要采取措施减少其他凭证（比如，refresh token)对这种客户端的暴露。

### 10.2 客户端仿冒

如果客户端没能保护好自己的凭证，仿冒者可以冒充别的客户端。

授权服务器必须尽可能地验证客户端的身份。如果由于客户端的天然属性，授权服务器无法进行身份验证，授权服务器必须要求注册重定向URI，并且应该利用其它手段来保护资源所有者免受仿冒者的危害。比如，授权服务器可以鼓励资源所有者帮助识别客户端和它的来源。

授权服务器应该显式和资源所有者执行授权过程，为资源所有者提供关于客户端，请求授权的范围，期限等信息。

授权服务器不应该自动重复授权请求（没有和资源所有者交互），在没有识别客户端身份的情况下，或者依靠其他手段来保证重复的请求是来自原始的客户端，而非仿冒者。

### 10.3 access token

必须通过TLS传输。

隐式授权模式下， acess token通过URI fragment传递，可能暴露。

本规范未提供资源服务器验证access token的方法。

### 10.4 refresh token

授权服务器应该验证refresh token和客户端id之间的关联，在任何可能验证客户端身份的场景下。如果客户端身份无法验证，应该采取其他手段来检测refresh token的滥用。

比如，授权服务器可以动态刷新refresh token，当用refresh token刷新access token时，生成一个新的refresh token。之前的refresh token失效掉，但是保存在授权服务器上。当一个refresh token连续被攻击者和合法客户端发送过来时，其中之一必定会提供一个失效的refresh token，这可以让授权服务器得到告警。

### 10.5 授权码

授权码必须是短时可用，且只能用一次。如果授权服务器检测到多次尝试用同一个授权码换取access token，授权服务器应该尝试收回基于泄漏的授权码而发布的access token。

### 10.6 授权码重定向URI操纵

授权服务器必须保证获取授权码的重定向URI和换取access token时提供的重定向URI是完全一样的。

### 10.7 资源所有者密码凭证模式

### 10.8 请求机密性

### 10.9 确保端点身份认证

客户端必须验证授权服务器的TLS证书。

### 10.10 凭证猜测攻击

攻击者猜到token的概率必须低于2^(-128)。token长度必须超过128位，16字节。

### 10.11 钓鱼攻击

让用户更容易鉴别出网站的真实性。

### 10.12 跨站请求伪造

在A网页中嵌入一个链接，去访问一个合法的构造好的B网站地址；由于用户已经在别的页签登录了B网站，coookie中带有会话信息，B网站对这次请求认为是用户发来的。相当于骗用户去做一个转账操作，这个操作依赖于cookie。保护措施是放置一个不在cookie中的数据项作为校验值，这个数据在A网页中是无法获取的。比如，服务器返回的HTML在表单中设置一个隐藏token，提交表单时要把这个token一并提交。

受害场景：

* 受害者访问一个web应用客户端，已经登录，在服务端生成了token；
* 此时点击了一个链接：`https://www.example/redirect_uri?code=xxx-of-attacker`，客户端据此生成了新的token，放到会话信息中；这时会话信息中的token是与攻击者关联的。
* 受害者继续操作，假设他输入账号信息，想保存到资源服务器上；由于token关联了攻击者，结果保存到了攻击者的帐号下。

客户端必须对重定向URI实现CSRF保护。一般是要求发到重定向URI端点的请求携带一个state字段，这个值比如是会话cookie的哈希值。受保护场景：

* 用户访问客户端，生成会话cookie
* 客户端把用户重定向到授权服务器，参数中带着state，这个state就是一个临时值，无法提前获知
* 授权服务器重定向回客户端redirect_uri，带着state参数
* 客户端重定向端点验证state是之前自己给的state，校验通过
* 用户点击链接
* 客户端重定向端点验证state非法

防CSRF，要求state是不能被猜到的。

### 10.13 点击劫持

授权服务器可以使用x-frame-options头来防点击劫持，该机制有两个选项：DENY 和 SAMEORIGIN。DENY表示任何网页都不能使用 iframe 载入该网页，SAMEORIGIN表示符合同源策略的网页可以使用 iframe载入该网页

### 10.14 代码注入和输入校验

授权服务器和客户端必须对接收到的任何参数做无害化处理，尤其是"state"和"redirect_uri"。

### 10.15 开放重定向

授权服务器，授权端点，客户端重定向端点，可以被不正确地配置，成为“开放重定向”。“开放重定向”是一个端点，接受一个参数来重定向用户代理到有参数值指定的地址，而没有做任何校验。

“开放重定向”可以被用来做钓鱼攻击，或者通过使用一个熟悉和信任地址的URI授权组件，让终端用户访问恶意网站。另外，如果授权服务器允许客户端只注册重定向URI的一部分，攻击者仍然可以使用“开放重定向”来构造重定向URI，可以通过授权服务器的合法性校验，但是会在攻击者的控制下发送授权码或者access token。

### 10.16 隐式流程中误用access token来扮演资源所有者

任何公共客户端，如果它假设只有资源所有者才能给它一个合法的access token，就很容易被攻击，因为攻击者可能会偷取到access token，然后给客户端（构造一个redirect_uri?token=xxx链接就可以）。如果与客户端交互的服务器也把access token作为其用户的身份，则服务器上的资源也会被攻击者访问和操控。

不能以access token来识别资源所有者，但是客户端认证它自己的资源所有者的身份，不在本文档的范围内。