# 算法题
## 无重复字符的最长子串
两个游标L,R。初始都在0位置。
R往右移动，依次跟[L,R-1]之间的字符做比较，从右往左的顺序。如果遇到一个跟R重复的字符i，则把L移到i+1。

## 最长公共前缀
非常容易。第一个字符开始遍历。注意空字符串，注意长度比第一个字符串要小的字符串。

## 字符串的排列
暴力解法：对s2进行滑窗，窗口大小为s1的长度，比较窗口和s1是否是同一个组合。把s1转换成map<char, int>，把滑窗也转换成map<char,int>，比较两个map是否一样。
高效解法：同样是滑窗。但是以int[26]的数组来记录各个字母出现的次数。
1、滑窗的过程，不需要构造新数组，只要调整数组对应字母的数字即可；
2、比较两个数组的大小比较高效。

## 最长回文子串
暴力解法：遍历所有子串:for(i in 0..len) for(j in i..len) s[i,j]是否为回文子串
动态规划解法：
长度1的子串：P[i,i]=true
长度2的子串：P[i,i+1]=s[i]==s[i+1]
长度n的子串：P[i,j]=P[i+1,j-1]&&s[i]==s[j]
for(len=1;len<s.length;len++){...}
