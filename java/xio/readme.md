
## 学习资料来源
[Scalable IO in Java](http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf)

## 可扩展的网络服务
一般都有如下几个步骤：
+ 读取请求
+ 解码请求
+ 处理服务
+ 编码响应
+ 发送响应
  
可扩展性的目标：  
* 随负载的增加（更多客户端连接），优雅降级
* 资源（CPU、内存、磁盘、带宽）的增加，能带来不断的提升
* 满足性能要求：短延迟，抗住峰值，可调节的服务数量
* 分而治之通常是满足任何扩展性目标的最佳办法
  
分而治之：  
* 把流程分成多个小任务，每个任务只做一个动作，单个任务不阻塞
* 当任务就绪的时候执行任务。在这里，通常把IO事件作为任务的触发者。
* java.nio中支持的基本机制为：非阻塞的读和写，分发与IO事件关联的任务。
* 可以有很多变种：很多基于事件驱动的设计。

## 事件驱动的处理方式
通常会比其他方案更高效  
* 更少的资源：不需要为每个客户端都使用一个线程
* 更少的开销：更少的上下文切换，通常更少的锁
* 但是分发任务可能会更慢：必须手动把动作与事件绑定  
更难编码  
* 必须把流程拆成简单的非阻塞的动作
* 必须追踪服务的逻辑状态

## 反应器模式
* 基础版本。在此基础上，可以采用“状态模式”（设计模式的一种），在每个阶段结束，就设置好下一个状态，重新绑定selectionKey的附件。
* 多线程版本
* 其他版本

## java.nio包中的非阻塞IO APIs
